{
	"name": "http-mcp",
	"description": "Template MCP con soporte HTTP/SSE para acceso web y Claude Desktop",
	"category": "http",
	"tags": ["http", "sse", "web", "dual-transport"],
	"files": {
		"package.json": {
			"content": "{\n\t\"name\": \"{{KEBAB_CASE_NAME}}\",\n\t\"version\": \"1.0.0\",\n\t\"description\": \"{{PROJECT_NAME}} - Proyecto MCP con soporte HTTP/SSE y STDIO\",\n\t\"type\": \"module\",\n\t\"main\": \"dist/index.js\",\n\t\"bin\": {\n\t\t\"{{KEBAB_CASE_NAME}}\": \"./dist/index.js\"\n\t},\n\t\"files\": [\"dist\", \"src\"],\n\t\"scripts\": {\n\t\t\"dev\": \"tsx watch src/index.ts\",\n\t\t\"dev:http\": \"MCP_TRANSPORT=http tsx watch src/index.ts\",\n\t\t\"build\": \"tsc && npm pack\",\n\t\t\"start\": \"node dist/index.js\",\n\t\t\"start:http\": \"MCP_TRANSPORT=http node dist/index.js\",\n\t\t\"install:global\": \"npm run build && npm install -g ./*.tgz\",\n\t\t\"inspector\": \"npx @modelcontextprotocol/inspector npx {{KEBAB_CASE_NAME}}\",\n\t\t\"inspect\": \"npx @modelcontextprotocol/inspector\",\n\t\t\"lint\": \"eslint src --ext .ts\"\n\t},\n\t\"dependencies\": {\n\t\t\"@modelcontextprotocol/sdk\": \"^1.0.1\",\n\t\t\"express\": \"^4.19.2\",\n\t\t\"dotenv\": \"^16.3.1\"\n\t},\n\t\"devDependencies\": {\n\t\t\"@types/node\": \"^20.0.0\",\n\t\t\"@types/express\": \"^4.17.0\",\n\t\t\"tsx\": \"^4.0.0\",\n\t\t\"typescript\": \"^5.0.0\",\n\t\t\"eslint\": \"^8.0.0\",\n\t\t\"@typescript-eslint/eslint-plugin\": \"^6.0.0\",\n\t\t\"@typescript-eslint/parser\": \"^6.0.0\"\n\t},\n\t\"keywords\": [\"mcp\", \"model-context-protocol\", \"http\", \"sse\", \"claude\", \"ai\", \"typescript\", \"nodejs\"],\n\t\"author\": \"MCP Bootstrap Generator\",\n\t\"license\": \"MIT\"\n}",
			"required": true,
			"description": "Configuración del proyecto con dependencias HTTP"
		},
		"tsconfig.json": {
			"content": "{\n\t\"compilerOptions\": {\n\t\t\"target\": \"ES2022\",\n\t\t\"module\": \"ESNext\",\n\t\t\"moduleResolution\": \"node\",\n\t\t\"esModuleInterop\": true,\n\t\t\"allowSyntheticDefaultImports\": true,\n\t\t\"strict\": true,\n\t\t\"declaration\": true,\n\t\t\"declarationMap\": true,\n\t\t\"sourceMap\": true,\n\t\t\"outDir\": \"./dist\",\n\t\t\"rootDir\": \"./src\",\n\t\t\"resolveJsonModule\": true,\n\t\t\"skipLibCheck\": true,\n\t\t\"forceConsistentCasingInFileNames\": true\n\t},\n\t\"include\": [\"src/**/*\"],\n\t\"exclude\": [\"node_modules\", \"dist\", \"**/*.test.ts\"]\n}",
			"required": true,
			"description": "Configuración TypeScript"
		},
		"src/index.ts": {
			"content": "#!/usr/bin/env node\n\nimport { Server } from '@modelcontextprotocol/sdk/server/index.js';\nimport { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';\nimport { CallToolRequestSchema, ListToolsRequestSchema } from '@modelcontextprotocol/sdk/types.js';\nimport { config } from 'dotenv';\nimport { startHttpServer } from './http-server.js';\nimport { MCP_TOOLS } from './mcp-tools.js';\nimport { ToolHandlers } from './tool-handlers.js';\n\nconfig();\n\nconst log = (...args: any[]) => console.error('[{{KEBAB_CASE_NAME}}]', ...args);\n\nasync function main() {\n\t// Get transport mode from environment\n\tconst mode = (process.env.MCP_TRANSPORT || 'stdio').toLowerCase();\n\n\ttry {\n\t\tconst toolHandlers = new ToolHandlers();\n\n\t\tif (mode === 'http') {\n\t\t\t// HTTP/SSE mode\n\t\t\tconst port = parseInt(process.env.MCP_PORT || process.env.PORT || '3000');\n\t\t\tconst corsOrigins = process.env.ALLOWED_ORIGINS || '*';\n\t\t\tconst bearerToken = process.env.MCP_BEARER;\n\t\t\tconst bodyLimit = process.env.MCP_BODY_LIMIT || '1mb';\n\n\t\t\tlog(`Starting HTTP server on port ${port}`);\n\t\t\tawait startHttpServer(toolHandlers, {\n\t\t\t\tport,\n\t\t\t\tcorsOrigins,\n\t\t\t\tbearerToken,\n\t\t\t\tbodyLimit,\n\t\t\t});\n\t\t} else {\n\t\t\t// STDIO mode (default)\n\t\t\tconst server = new Server(\n\t\t\t\t{ name: '{{KEBAB_CASE_NAME}}', version: '1.0.0' },\n\t\t\t\t{ capabilities: { tools: {} } }\n\t\t\t);\n\n\t\t\tserver.setRequestHandler(ListToolsRequestSchema, async () => ({\n\t\t\t\ttools: MCP_TOOLS,\n\t\t\t}));\n\n\t\t\tserver.setRequestHandler(CallToolRequestSchema, async (request) => {\n\t\t\t\treturn await toolHandlers.handleToolCall(request);\n\t\t\t});\n\n\t\t\tconst transport = new StdioServerTransport();\n\t\t\tawait server.connect(transport);\n\t\t\tlog('STDIO mode ready for Claude Desktop');\n\t\t}\n\n\t\tprocess.on('SIGINT', () => process.exit(0));\n\t} catch (error) {\n\t\tlog('ERROR:', error);\n\t\tprocess.exit(1);\n\t}\n}\n\nmain().catch((error) => {\n\tlog('FATAL:', error);\n\tprocess.exit(1);\n});",
			"required": true,
			"description": "Servidor principal con soporte dual (STDIO + HTTP)"
		},
		"src/http-server.ts": {
			"content": "import { Server } from '@modelcontextprotocol/sdk/server/index.js';\nimport { SSEServerTransport } from '@modelcontextprotocol/sdk/server/sse.js';\nimport { CallToolRequestSchema, ListToolsRequestSchema } from '@modelcontextprotocol/sdk/types.js';\nimport express from 'express';\nimport { MCP_TOOLS } from './mcp-tools.js';\nimport { ToolHandlers } from './tool-handlers.js';\n\ninterface HttpServerOptions {\n\tport?: number;\n\tcorsOrigins?: string;\n\tbodyLimit?: string;\n\tbearerToken?: string;\n}\n\nexport async function startHttpServer(\n\ttoolHandlers: ToolHandlers,\n\toptions: HttpServerOptions = {}\n): Promise<void> {\n\tconst {\n\t\tport = 3000,\n\t\tcorsOrigins = '*',\n\t\tbodyLimit = '1mb',\n\t\tbearerToken,\n\t} = options;\n\n\tconst app = express();\n\n\t// Middleware básico\n\tapp.use(express.json({ limit: bodyLimit }));\n\n\t// CORS\n\tapp.use((req, res, next) => {\n\t\tres.header('Access-Control-Allow-Origin', corsOrigins);\n\t\tres.header('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');\n\t\tres.header('Access-Control-Allow-Headers', 'Content-Type, Authorization');\n\t\tif (req.method === 'OPTIONS') {\n\t\t\tres.sendStatus(200);\n\t\t\treturn;\n\t\t}\n\t\tnext();\n\t});\n\n\t// Autenticación Bearer (opcional)\n\tif (bearerToken) {\n\t\tapp.use('/sse', (req, res, next) => {\n\t\t\tconst auth = req.headers.authorization;\n\t\t\tif (!auth || !auth.startsWith('Bearer ') || auth.slice(7) !== bearerToken) {\n\t\t\t\tres.status(401).json({ error: 'Unauthorized' });\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tnext();\n\t\t});\n\t}\n\n\t// Health check\n\tapp.get('/health', (req, res) => {\n\t\tres.json({ status: 'healthy', service: '{{KEBAB_CASE_NAME}}' });\n\t});\n\n\t// Información del servidor\n\tapp.get('/info', (req, res) => {\n\t\tres.json({\n\t\t\tname: '{{KEBAB_CASE_NAME}}',\n\t\t\tversion: '1.0.0',\n\t\t\tdescription: '{{PROJECT_NAME}}',\n\t\t\ttools: MCP_TOOLS.length,\n\t\t\ttransport: 'http-sse',\n\t\t});\n\t});\n\n\t// Endpoint SSE para MCP\n\tapp.get('/sse', async (req, res) => {\n\t\tconsole.log('New SSE connection');\n\n\t\tconst server = new Server(\n\t\t\t{ name: '{{KEBAB_CASE_NAME}}', version: '1.0.0' },\n\t\t\t{ capabilities: { tools: {} } }\n\t\t);\n\n\t\tserver.setRequestHandler(ListToolsRequestSchema, async () => ({\n\t\t\ttools: MCP_TOOLS,\n\t\t}));\n\n\t\tserver.setRequestHandler(CallToolRequestSchema, async (request) => {\n\t\t\treturn await toolHandlers.handleToolCall(request);\n\t\t});\n\n\t\tconst transport = new SSEServerTransport('/message', res);\n\t\tawait server.connect(transport);\n\t});\n\n\t// Iniciar servidor\n\tapp.listen(port, () => {\n\t\tconsole.log(`🚀 HTTP Server running on port ${port}`);\n\t\tconsole.log(`📡 SSE endpoint: http://localhost:${port}/sse`);\n\t\tconsole.log(`💚 Health check: http://localhost:${port}/health`);\n\t\tif (bearerToken) {\n\t\t\tconsole.log(`🔐 Authentication: Bearer token required`);\n\t\t}\n\t});\n}",
			"required": true,
			"description": "Servidor HTTP con SSE para acceso web"
		},
		"src/mcp-tools.ts": {
			"content": "import { Tool } from '@modelcontextprotocol/sdk/types.js';\n\nexport const MCP_TOOLS: Tool[] = [\n\t{\n\t\tname: 'hello_world',\n\t\tdescription: 'Herramienta de ejemplo que saluda',\n\t\tinputSchema: {\n\t\t\ttype: 'object',\n\t\t\tproperties: {\n\t\t\t\tname: {\n\t\t\t\t\ttype: 'string',\n\t\t\t\t\tdescription: 'Nombre para saludar',\n\t\t\t\t\tdefault: 'World',\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t},\n\t{\n\t\tname: 'get_server_info',\n\t\tdescription: 'Obtiene información del servidor MCP',\n\t\tinputSchema: {\n\t\t\ttype: 'object',\n\t\t\tproperties: {},\n\t\t},\n\t},\n];",
			"required": true,
			"description": "Definiciones de herramientas MCP"
		},
		"src/tool-handlers.ts": {
			"content": "import { ErrorCode, McpError } from '@modelcontextprotocol/sdk/types.js';\n\nexport class ToolHandlers {\n\tasync handleToolCall(request: any) {\n\t\tconst { name, arguments: args } = request.params;\n\n\t\ttry {\n\t\t\tswitch (name) {\n\t\t\t\tcase 'hello_world':\n\t\t\t\t\treturn await this.handleHelloWorld(args);\n\t\t\t\tcase 'get_server_info':\n\t\t\t\t\treturn await this.handleGetServerInfo(args);\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new McpError(ErrorCode.MethodNotFound, `Herramienta desconocida: ${name}`);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tconsole.error(`Error in tool ${name}:`, error);\n\t\t\tthrow new McpError(\n\t\t\t\tErrorCode.InternalError,\n\t\t\t\t`Error ejecutando herramienta '${name}': ${error instanceof Error ? error.message : String(error)}`\n\t\t\t);\n\t\t}\n\t}\n\n\tprivate async handleHelloWorld(args: any) {\n\t\tconst name = args?.name || 'World';\n\t\treturn {\n\t\t\tcontent: [{\n\t\t\t\ttype: 'text',\n\t\t\t\ttext: `¡Hola, ${name}! Este es {{PROJECT_NAME}} funcionando correctamente vía ${process.env.MCP_TRANSPORT || 'STDIO'}.`,\n\t\t\t}],\n\t\t};\n\t}\n\n\tprivate async handleGetServerInfo(args: any) {\n\t\tconst mode = process.env.MCP_TRANSPORT || 'stdio';\n\t\tconst port = process.env.MCP_PORT || process.env.PORT;\n\t\t\n\t\treturn {\n\t\t\tcontent: [{\n\t\t\t\ttype: 'text',\n\t\t\t\ttext: `📊 Información del servidor:\\n\\n- Proyecto: {{PROJECT_NAME}}\\n- Versión: 1.0.0\\n- Modo: ${mode.toUpperCase()}\\n${port ? `- Puerto: ${port}\\n` : ''}- Node.js: ${process.version}\\n- Plataforma: ${process.platform}\\n- Tiempo activo: ${process.uptime()} segundos\\n- Capacidades: HTTP/SSE + STDIO`,\n\t\t\t}],\n\t\t};\n\t}\n}",
			"required": true,
			"description": "Manejadores de herramientas MCP"
		},
		"env.example": {
			"content": "# === CONFIGURACIÓN PRINCIPAL ===\\n# Transporte: 'http' para servidor HTTP, 'stdio' para STDIO\\nMCP_TRANSPORT=stdio\\n\\n# Puerto donde se expondrá el servidor HTTP (solo aplica si MCP_TRANSPORT=http)\\nMCP_PORT=3000\\nPORT=3000\\n\\n# === AUTENTICACIÓN ===\\n# Token Bearer para autenticación (opcional - si no se define, modo abierto)\\nMCP_BEARER=your-secure-token\\n\\n# === CORS ===\\n# Orígenes permitidos para CORS (separados por coma)\\nALLOWED_ORIGINS=*\\n\\n# === CONFIGURACIÓN TÉCNICA ===\\n# Límite de tamaño del body de requests\\nMCP_BODY_LIMIT=1mb\\n\\n# Nivel de logging\\nLOG_LEVEL=info",
			"required": false,
			"description": "Variables de entorno para configuración dual"
		},
		"README.md": {
			"content": "# {{PROJECT_NAME}}\\n\\n{{PROJECT_NAME}} - Proyecto MCP con soporte HTTP/SSE y STDIO generado con Bootstrap Project MCP.\\n\\n## 🚀 Características\\n\\n- ✅ **Doble transporte**: STDIO (Claude Desktop) + HTTP/SSE (Web)\\n- ✅ **Autenticación Bearer** opcional\\n- ✅ **CORS configurable**\\n- ✅ **Health checks** y endpoints de información\\n- ✅ **Desarrollo en vivo** con recarga automática\\n\\n## 🚀 Instalación\\n\\n```bash\\n# Instalar dependencias\\npnpm install\\n\\n# Compilar proyecto\\npnpm run build\\n\\n# Instalar globalmente\\npnpm run install:global\\n```\\n\\n## 🔧 Configuración\\n\\n### Claude Desktop (STDIO)\\n\\nAgregar a tu `mcp.json`:\\n\\n```json\\n{\\n\\t\\\"mcpServers\\\": {\\n\\t\\t\\\"{{KEBAB_CASE_NAME}}\\\": {\\n\\t\\t\\t\\\"command\\\": \\\"npx\\\",\\n\\t\\t\\t\\\"args\\\": [\\\"{{KEBAB_CASE_NAME}}\\\"],\\n\\t\\t\\t\\\"env\\\": {\\n\\t\\t\\t\\t\\\"MCP_TRANSPORT\\\": \\\"stdio\\\"\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n```\\n\\n### Acceso Web (HTTP/SSE)\\n\\n```bash\\n# Configurar variables de entorno\\ncp env.example .env\\n\\n# Editar .env con tu configuración:\\n# MCP_TRANSPORT=http\\n# MCP_PORT=3000\\n# MCP_BEARER=tu-token-seguro\\n\\n# Iniciar servidor HTTP\\npnpm run start:http\\n```\\n\\n## 🛠️ Herramientas Disponibles\\n\\n- **hello_world**: Herramienta de ejemplo que saluda\\n- **get_server_info**: Obtiene información del servidor MCP\\n\\n## 🧪 Testing\\n\\n```bash\\n# Modo STDIO (Claude Desktop)\\npnpm run inspector\\n\\n# Modo HTTP (desarrollo)\\npnpm run dev:http\\n\\n# Desarrollo STDIO\\npnpm run dev\\n```\\n\\n## 🌐 Endpoints HTTP\\n\\n- `GET /health` - Health check\\n- `GET /info` - Información del servidor\\n- `GET /sse` - Endpoint SSE para MCP\\n\\n## 📄 Licencia\\n\\nMIT License",
			"required": true,
			"description": "Documentación del proyecto HTTP/SSE"
		},
		"mcp.json": {
			"content": "{\\n\\t\\\"mcpServers\\\": {\\n\\t\\t\\\"{{KEBAB_CASE_NAME}}\\\": {\\n\\t\\t\\t\\\"command\\\": \\\"npx\\\",\\n\\t\\t\\t\\\"args\\\": [\\\"{{KEBAB_CASE_NAME}}\\\"],\\n\\t\\t\\t\\\"env\\\": {\\n\\t\\t\\t\\t\\\"MCP_TRANSPORT\\\": \\\"stdio\\\"\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}",
			"required": true,
			"description": "Configuración para Claude Desktop"
		}
	}
}
