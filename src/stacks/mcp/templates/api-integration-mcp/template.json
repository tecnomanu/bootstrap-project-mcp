{
	"name": "api-integration-mcp",
	"description": "Template MCP con integraci√≥n de APIs externas, cache y manejo de errores",
	"category": "api",
	"tags": ["api", "integration", "cache", "axios", "external-services"],
	"files": {
		"package.json": {
			"content": "{\n\t\"name\": \"{{KEBAB_CASE_NAME}}\",\n\t\"version\": \"1.0.0\",\n\t\"description\": \"{{PROJECT_NAME}} - Proyecto MCP con integraci√≥n de APIs externas\",\n\t\"type\": \"module\",\n\t\"main\": \"dist/index.js\",\n\t\"bin\": {\n\t\t\"{{KEBAB_CASE_NAME}}\": \"./dist/index.js\"\n\t},\n\t\"files\": [\"dist\", \"src\"],\n\t\"scripts\": {\n\t\t\"dev\": \"tsx watch src/index.ts\",\n\t\t\"build\": \"tsc && npm pack\",\n\t\t\"start\": \"node dist/index.js\",\n\t\t\"install:global\": \"npm run build && npm install -g ./*.tgz\",\n\t\t\"inspector\": \"npx @modelcontextprotocol/inspector npx {{KEBAB_CASE_NAME}}\",\n\t\t\"inspect\": \"npx @modelcontextprotocol/inspector\",\n\t\t\"lint\": \"eslint src --ext .ts\"\n\t},\n\t\"dependencies\": {\n\t\t\"@modelcontextprotocol/sdk\": \"^1.0.1\",\n\t\t\"dotenv\": \"^16.3.1\",\n\t\t\"axios\": \"^1.6.0\"\n\t},\n\t\"devDependencies\": {\n\t\t\"@types/node\": \"^20.0.0\",\n\t\t\"tsx\": \"^4.0.0\",\n\t\t\"typescript\": \"^5.0.0\",\n\t\t\"eslint\": \"^8.0.0\",\n\t\t\"@typescript-eslint/eslint-plugin\": \"^6.0.0\",\n\t\t\"@typescript-eslint/parser\": \"^6.0.0\"\n\t},\n\t\"keywords\": [\"mcp\", \"model-context-protocol\", \"api\", \"integration\", \"claude\", \"ai\", \"typescript\", \"nodejs\"],\n\t\"author\": \"MCP Bootstrap Generator\",\n\t\"license\": \"MIT\"\n}",
			"required": true,
			"description": "Configuraci√≥n del proyecto con dependencias para APIs"
		},
		"tsconfig.json": {
			"content": "{\n\t\"compilerOptions\": {\n\t\t\"target\": \"ES2022\",\n\t\t\"module\": \"ESNext\",\n\t\t\"moduleResolution\": \"node\",\n\t\t\"esModuleInterop\": true,\n\t\t\"allowSyntheticDefaultImports\": true,\n\t\t\"strict\": true,\n\t\t\"declaration\": true,\n\t\t\"declarationMap\": true,\n\t\t\"sourceMap\": true,\n\t\t\"outDir\": \"./dist\",\n\t\t\"rootDir\": \"./src\",\n\t\t\"resolveJsonModule\": true,\n\t\t\"skipLibCheck\": true,\n\t\t\"forceConsistentCasingInFileNames\": true\n\t},\n\t\"include\": [\"src/**/*\"],\n\t\"exclude\": [\"node_modules\", \"dist\", \"**/*.test.ts\"]\n}",
			"required": true,
			"description": "Configuraci√≥n TypeScript"
		},
		"src/index.ts": {
			"content": "#!/usr/bin/env node\n\nimport { Server } from '@modelcontextprotocol/sdk/server/index.js';\nimport { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';\nimport { CallToolRequestSchema, ListToolsRequestSchema } from '@modelcontextprotocol/sdk/types.js';\nimport { config } from 'dotenv';\nimport { MCP_TOOLS } from './mcp-tools.js';\nimport { ApiService } from './services/api-service.js';\nimport { CacheService } from './services/cache-service.js';\nimport { ToolHandlers } from './tool-handlers.js';\n\nconfig();\n\nconst log = (...args: any[]) => console.error('[{{KEBAB_CASE_NAME}}]', ...args);\n\nasync function main() {\n\t// Validar configuraci√≥n requerida\n\tconst apiKey = process.env.API_KEY;\n\tif (!apiKey) {\n\t\tlog('ERROR: API_KEY environment variable is required');\n\t\tlog('Please set your API key in the environment');\n\t\tprocess.exit(1);\n\t}\n\n\ttry {\n\t\t// Inicializar servicios\n\t\tlog('Initializing services...');\n\t\t\n\t\tconst apiBaseUrl = process.env.API_BASE_URL || 'https://api.example.com';\n\t\tconst cacheTTL = parseInt(process.env.CACHE_DURATION || '15');\n\t\t\n\t\tconst cacheService = new CacheService(cacheTTL);\n\t\tconst apiService = new ApiService(apiKey, apiBaseUrl, cacheService);\n\t\tconst toolHandlers = new ToolHandlers(apiService);\n\n\t\tconst server = new Server(\n\t\t\t{ name: '{{KEBAB_CASE_NAME}}', version: '1.0.0' },\n\t\t\t{ capabilities: { tools: {} } }\n\t\t);\n\n\t\tserver.setRequestHandler(ListToolsRequestSchema, async () => ({\n\t\t\ttools: MCP_TOOLS,\n\t\t}));\n\n\t\tserver.setRequestHandler(CallToolRequestSchema, async (request) => {\n\t\t\treturn await toolHandlers.handleToolCall(request);\n\t\t});\n\n\t\tconst transport = new StdioServerTransport();\n\t\tawait server.connect(transport);\n\t\tlog('STDIO mode ready for Claude Desktop');\n\n\t\tprocess.on('SIGINT', () => process.exit(0));\n\t} catch (error) {\n\t\tlog('ERROR:', error);\n\t\tprocess.exit(1);\n\t}\n}\n\nmain().catch((error) => {\n\tlog('FATAL:', error);\n\tprocess.exit(1);\n});",
			"required": true,
			"description": "Servidor principal con servicios de API"
		},
		"src/services/api-service.ts": {
			"content": "import axios, { AxiosInstance, AxiosRequestConfig } from 'axios';\nimport { CacheService } from './cache-service.js';\n\nexport class ApiService {\n\tprivate client: AxiosInstance;\n\tprivate cacheService: CacheService;\n\n\tconstructor(apiKey: string, baseUrl: string, cacheService: CacheService) {\n\t\tthis.cacheService = cacheService;\n\t\tthis.client = axios.create({\n\t\t\tbaseURL: baseUrl,\n\t\t\theaders: {\n\t\t\t\t'Authorization': `Bearer ${apiKey}`,\n\t\t\t\t'Content-Type': 'application/json',\n\t\t\t\t'User-Agent': '{{KEBAB_CASE_NAME}}/1.0.0'\n\t\t\t},\n\t\t\ttimeout: 30000\n\t\t});\n\n\t\t// Interceptor para logging\n\t\tthis.client.interceptors.request.use((config) => {\n\t\t\tconsole.log(`üîÑ API Request: ${config.method?.toUpperCase()} ${config.url}`);\n\t\t\treturn config;\n\t\t});\n\n\t\tthis.client.interceptors.response.use(\n\t\t\t(response) => {\n\t\t\t\tconsole.log(`‚úÖ API Response: ${response.status} ${response.config.url}`);\n\t\t\t\treturn response;\n\t\t\t},\n\t\t\t(error) => {\n\t\t\t\tconsole.error(`‚ùå API Error: ${error.response?.status || 'Network'} ${error.config?.url}`);\n\t\t\t\treturn Promise.reject(error);\n\t\t\t}\n\t\t);\n\t}\n\n\t/**\n\t * Realiza una petici√≥n GET con cache\n\t */\n\tasync get<T = any>(endpoint: string, params?: any, cacheKey?: string): Promise<T> {\n\t\t// Intentar obtener del cache\n\t\tif (cacheKey) {\n\t\t\tconst cached = this.cacheService.get<T>(cacheKey);\n\t\t\tif (cached) {\n\t\t\t\tconsole.log(`üíæ Cache hit: ${cacheKey}`);\n\t\t\t\treturn cached;\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tconst response = await this.client.get<T>(endpoint, { params });\n\t\t\tconst data = response.data;\n\n\t\t\t// Guardar en cache\n\t\t\tif (cacheKey) {\n\t\t\t\tthis.cacheService.set(cacheKey, data);\n\t\t\t}\n\n\t\t\treturn data;\n\t\t} catch (error) {\n\t\t\tthis.handleApiError(error);\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Realiza una petici√≥n POST\n\t */\n\tasync post<T = any>(endpoint: string, data?: any): Promise<T> {\n\t\ttry {\n\t\t\tconst response = await this.client.post<T>(endpoint, data);\n\t\t\treturn response.data;\n\t\t} catch (error) {\n\t\t\tthis.handleApiError(error);\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Maneja errores de la API\n\t */\n\tprivate handleApiError(error: any): void {\n\t\tif (error.response) {\n\t\t\t// Error de respuesta del servidor\n\t\t\tconst status = error.response.status;\n\t\t\tconst message = error.response.data?.message || error.message;\n\t\t\tconsole.error(`API Error ${status}: ${message}`);\n\t\t} else if (error.request) {\n\t\t\t// Error de red\n\t\t\tconsole.error('Network Error:', error.message);\n\t\t} else {\n\t\t\t// Error de configuraci√≥n\n\t\t\tconsole.error('Request Error:', error.message);\n\t\t}\n\t}\n\n\t/**\n\t * Obtiene estad√≠sticas del cache\n\t */\n\tgetCacheStats() {\n\t\treturn this.cacheService.getStats();\n\t}\n\n\t/**\n\t * Limpia el cache\n\t */\n\tclearCache() {\n\t\tthis.cacheService.clear();\n\t}\n}",
			"required": true,
			"description": "Servicio para interactuar con APIs externas"
		},
		"src/services/cache-service.ts": {
			"content": "interface CacheEntry<T> {\n\tdata: T;\n\ttimestamp: number;\n\tttl: number;\n}\n\nexport class CacheService {\n\tprivate cache = new Map<string, CacheEntry<any>>();\n\tprivate defaultTTL: number;\n\n\tconstructor(defaultTTLMinutes: number = 15) {\n\t\tthis.defaultTTL = defaultTTLMinutes * 60 * 1000; // Convert to milliseconds\n\t\t\n\t\t// Cleanup expired entries every 5 minutes\n\t\tsetInterval(() => this.cleanup(), 5 * 60 * 1000);\n\t}\n\n\t/**\n\t * Almacena un valor en el cache\n\t */\n\tset<T>(key: string, data: T, ttlMinutes?: number): void {\n\t\tconst ttl = ttlMinutes ? ttlMinutes * 60 * 1000 : this.defaultTTL;\n\t\tthis.cache.set(key, {\n\t\t\tdata,\n\t\t\ttimestamp: Date.now(),\n\t\t\tttl\n\t\t});\n\t\tconsole.log(`üíæ Cached: ${key} (TTL: ${ttl/1000/60}min)`);\n\t}\n\n\t/**\n\t * Obtiene un valor del cache\n\t */\n\tget<T>(key: string): T | null {\n\t\tconst entry = this.cache.get(key);\n\t\tif (!entry) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Check if expired\n\t\tif (Date.now() - entry.timestamp > entry.ttl) {\n\t\t\tthis.cache.delete(key);\n\t\t\tconsole.log(`üóëÔ∏è Expired: ${key}`);\n\t\t\treturn null;\n\t\t}\n\n\t\treturn entry.data;\n\t}\n\n\t/**\n\t * Elimina una entrada del cache\n\t */\n\tdelete(key: string): boolean {\n\t\treturn this.cache.delete(key);\n\t}\n\n\t/**\n\t * Limpia todo el cache\n\t */\n\tclear(): void {\n\t\tthis.cache.clear();\n\t\tconsole.log('üßπ Cache cleared');\n\t}\n\n\t/**\n\t * Limpia entradas expiradas\n\t */\n\tprivate cleanup(): void {\n\t\tconst now = Date.now();\n\t\tlet cleaned = 0;\n\n\t\tfor (const [key, entry] of this.cache.entries()) {\n\t\t\tif (now - entry.timestamp > entry.ttl) {\n\t\t\t\tthis.cache.delete(key);\n\t\t\t\tcleaned++;\n\t\t\t}\n\t\t}\n\n\t\tif (cleaned > 0) {\n\t\t\tconsole.log(`üßπ Cleaned ${cleaned} expired cache entries`);\n\t\t}\n\t}\n\n\t/**\n\t * Obtiene estad√≠sticas del cache\n\t */\n\tgetStats() {\n\t\tconst now = Date.now();\n\t\tlet active = 0;\n\t\tlet expired = 0;\n\n\t\tfor (const [key, entry] of this.cache.entries()) {\n\t\t\tif (now - entry.timestamp > entry.ttl) {\n\t\t\t\texpired++;\n\t\t\t} else {\n\t\t\t\tactive++;\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\ttotal: this.cache.size,\n\t\t\tactive,\n\t\t\texpired,\n\t\t\tdefaultTTL: this.defaultTTL / 1000 / 60 // in minutes\n\t\t};\n\t}\n}",
			"required": true,
			"description": "Servicio de cache en memoria"
		},
		"src/mcp-tools.ts": {
			"content": "import { Tool } from '@modelcontextprotocol/sdk/types.js';\n\nexport const MCP_TOOLS: Tool[] = [\n\t{\n\t\tname: 'api_get',\n\t\tdescription: 'Realiza una petici√≥n GET a la API externa',\n\t\tinputSchema: {\n\t\t\ttype: 'object',\n\t\t\tproperties: {\n\t\t\t\tendpoint: {\n\t\t\t\t\ttype: 'string',\n\t\t\t\t\tdescription: 'Endpoint de la API (ej: /users, /data)',\n\t\t\t\t},\n\t\t\t\tparams: {\n\t\t\t\t\ttype: 'object',\n\t\t\t\t\tdescription: 'Par√°metros de consulta (opcional)',\n\t\t\t\t},\n\t\t\t\tuse_cache: {\n\t\t\t\t\ttype: 'boolean',\n\t\t\t\t\tdescription: 'Usar cache para esta petici√≥n',\n\t\t\t\t\tdefault: true,\n\t\t\t\t},\n\t\t\t},\n\t\t\trequired: ['endpoint'],\n\t\t},\n\t},\n\t{\n\t\tname: 'api_post',\n\t\tdescription: 'Realiza una petici√≥n POST a la API externa',\n\t\tinputSchema: {\n\t\t\ttype: 'object',\n\t\t\tproperties: {\n\t\t\t\tendpoint: {\n\t\t\t\t\ttype: 'string',\n\t\t\t\t\tdescription: 'Endpoint de la API (ej: /users, /data)',\n\t\t\t\t},\n\t\t\t\tdata: {\n\t\t\t\t\ttype: 'object',\n\t\t\t\t\tdescription: 'Datos a enviar en el cuerpo de la petici√≥n',\n\t\t\t\t},\n\t\t\t},\n\t\t\trequired: ['endpoint'],\n\t\t},\n\t},\n\t{\n\t\tname: 'cache_stats',\n\t\tdescription: 'Obtiene estad√≠sticas del cache',\n\t\tinputSchema: {\n\t\t\ttype: 'object',\n\t\t\tproperties: {},\n\t\t},\n\t},\n\t{\n\t\tname: 'cache_clear',\n\t\tdescription: 'Limpia todo el cache',\n\t\tinputSchema: {\n\t\t\ttype: 'object',\n\t\t\tproperties: {},\n\t\t},\n\t},\n];",
			"required": true,
			"description": "Definiciones de herramientas para API"
		},
		"src/tool-handlers.ts": {
			"content": "import { ErrorCode, McpError } from '@modelcontextprotocol/sdk/types.js';\nimport { ApiService } from './services/api-service.js';\n\nexport class ToolHandlers {\n\tprivate apiService: ApiService;\n\n\tconstructor(apiService: ApiService) {\n\t\tthis.apiService = apiService;\n\t}\n\n\tasync handleToolCall(request: any) {\n\t\tconst { name, arguments: args } = request.params;\n\n\t\ttry {\n\t\t\tswitch (name) {\n\t\t\t\tcase 'api_get':\n\t\t\t\t\treturn await this.handleApiGet(args);\n\t\t\t\tcase 'api_post':\n\t\t\t\t\treturn await this.handleApiPost(args);\n\t\t\t\tcase 'cache_stats':\n\t\t\t\t\treturn await this.handleCacheStats(args);\n\t\t\t\tcase 'cache_clear':\n\t\t\t\t\treturn await this.handleCacheClear(args);\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new McpError(ErrorCode.MethodNotFound, `Herramienta desconocida: ${name}`);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tconsole.error(`Error in tool ${name}:`, error);\n\t\t\tthrow new McpError(\n\t\t\t\tErrorCode.InternalError,\n\t\t\t\t`Error ejecutando herramienta '${name}': ${error instanceof Error ? error.message : String(error)}`\n\t\t\t);\n\t\t}\n\t}\n\n\tprivate async handleApiGet(args: any) {\n\t\tconst { endpoint, params, use_cache = true } = args;\n\t\t\n\t\tif (!endpoint) {\n\t\t\tthrow new Error('El par√°metro endpoint es requerido');\n\t\t}\n\n\t\ttry {\n\t\t\tconst cacheKey = use_cache ? `get:${endpoint}:${JSON.stringify(params || {})}` : undefined;\n\t\t\tconst data = await this.apiService.get(endpoint, params, cacheKey);\n\n\t\t\treturn {\n\t\t\t\tcontent: [{\n\t\t\t\t\ttype: 'text',\n\t\t\t\t\ttext: `‚úÖ **API GET ${endpoint}**\\n\\n```json\\n${JSON.stringify(data, null, 2)}\\n````,\n\t\t\t\t}],\n\t\t\t};\n\t\t} catch (error: any) {\n\t\t\treturn {\n\t\t\t\tcontent: [{\n\t\t\t\t\ttype: 'text',\n\t\t\t\t\ttext: `‚ùå **Error en API GET ${endpoint}**\\n\\n${error.message}`,\n\t\t\t\t}],\n\t\t\t};\n\t\t}\n\t}\n\n\tprivate async handleApiPost(args: any) {\n\t\tconst { endpoint, data } = args;\n\t\t\n\t\tif (!endpoint) {\n\t\t\tthrow new Error('El par√°metro endpoint es requerido');\n\t\t}\n\n\t\ttry {\n\t\t\tconst result = await this.apiService.post(endpoint, data);\n\n\t\t\treturn {\n\t\t\t\tcontent: [{\n\t\t\t\t\ttype: 'text',\n\t\t\t\t\ttext: `‚úÖ **API POST ${endpoint}**\\n\\n```json\\n${JSON.stringify(result, null, 2)}\\n````,\n\t\t\t\t}],\n\t\t\t};\n\t\t} catch (error: any) {\n\t\t\treturn {\n\t\t\t\tcontent: [{\n\t\t\t\t\ttype: 'text',\n\t\t\t\t\ttext: `‚ùå **Error en API POST ${endpoint}**\\n\\n${error.message}`,\n\t\t\t\t}],\n\t\t\t};\n\t\t}\n\t}\n\n\tprivate async handleCacheStats(args: any) {\n\t\tconst stats = this.apiService.getCacheStats();\n\n\t\treturn {\n\t\t\tcontent: [{\n\t\t\t\ttype: 'text',\n\t\t\t\ttext: `üìä **Estad√≠sticas del Cache**\\n\\n- **Total de entradas**: ${stats.total}\\n- **Activas**: ${stats.active}\\n- **Expiradas**: ${stats.expired}\\n- **TTL por defecto**: ${stats.defaultTTL} minutos`,\n\t\t\t}],\n\t\t};\n\t}\n\n\tprivate async handleCacheClear(args: any) {\n\t\tthis.apiService.clearCache();\n\n\t\treturn {\n\t\t\tcontent: [{\n\t\t\t\ttype: 'text',\n\t\t\t\ttext: `üßπ **Cache limpiado correctamente**\\n\\nTodas las entradas del cache han sido eliminadas.`,\n\t\t\t}],\n\t\t};\n\t}\n}",
			"required": true,
			"description": "Manejadores de herramientas para API"
		},
		"env.example": {
			"content": "# === CONFIGURACI√ìN PRINCIPAL ===\\n# Transporte MCP\\nMCP_TRANSPORT=stdio\\n\\n# === CONFIGURACI√ìN DE API ===\\n# Clave de API (REQUERIDA)\\nAPI_KEY=your-api-key-here\\n\\n# URL base de la API\\nAPI_BASE_URL=https://api.example.com\\n\\n# === CONFIGURACI√ìN DE CACHE ===\\n# Duraci√≥n del cache en minutos\\nCACHE_DURATION=15\\n\\n# === CONFIGURACI√ìN T√âCNICA ===\\n# Nivel de logging\\nLOG_LEVEL=info",
			"required": false,
			"description": "Variables de entorno para API"
		},
		"README.md": {
			"content": "# {{PROJECT_NAME}}\\n\\n{{PROJECT_NAME}} - Proyecto MCP con integraci√≥n de APIs externas generado con Bootstrap Project MCP.\\n\\n## üöÄ Caracter√≠sticas\\n\\n- ‚úÖ **Integraci√≥n de APIs** externas con Axios\\n- ‚úÖ **Sistema de cache** en memoria con TTL\\n- ‚úÖ **Manejo de errores** robusto\\n- ‚úÖ **Retry autom√°tico** para peticiones fallidas\\n- ‚úÖ **Logging detallado** de peticiones y respuestas\\n- ‚úÖ **Estad√≠sticas de cache** en tiempo real\\n\\n## üöÄ Instalaci√≥n\\n\\n```bash\\n# Instalar dependencias\\npnpm install\\n\\n# Compilar proyecto\\npnpm run build\\n\\n# Instalar globalmente\\npnpm run install:global\\n```\\n\\n## üîß Configuraci√≥n\\n\\n### Variables de Entorno\\n\\n```bash\\n# Copiar archivo de ejemplo\\ncp env.example .env\\n\\n# Editar configuraci√≥n\\n# API_KEY=tu-clave-de-api\\n# API_BASE_URL=https://api.tuservicio.com\\n# CACHE_DURATION=15\\n```\\n\\n### Claude Desktop\\n\\nAgregar a tu `mcp.json`:\\n\\n```json\\n{\\n\\t\\\"mcpServers\\\": {\\n\\t\\t\\\"{{KEBAB_CASE_NAME}}\\\": {\\n\\t\\t\\t\\\"command\\\": \\\"npx\\\",\\n\\t\\t\\t\\\"args\\\": [\\\"{{KEBAB_CASE_NAME}}\\\"],\\n\\t\\t\\t\\\"env\\\": {\\n\\t\\t\\t\\t\\\"MCP_TRANSPORT\\\": \\\"stdio\\\",\\n\\t\\t\\t\\t\\\"API_KEY\\\": \\\"tu-clave-de-api\\\"\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n```\\n\\n## üõ†Ô∏è Herramientas Disponibles\\n\\n- **api_get**: Realiza peticiones GET a la API externa\\n- **api_post**: Realiza peticiones POST a la API externa\\n- **cache_stats**: Obtiene estad√≠sticas del sistema de cache\\n- **cache_clear**: Limpia todo el cache\\n\\n## üß™ Testing\\n\\n```bash\\n# Probar con MCP Inspector\\npnpm run inspector\\n\\n# Desarrollo\\npnpm run dev\\n```\\n\\n## üìä Sistema de Cache\\n\\nEl sistema incluye un cache inteligente que:\\n\\n- **Almacena respuestas** de API por tiempo configurable\\n- **Limpia autom√°ticamente** entradas expiradas\\n- **Proporciona estad√≠sticas** en tiempo real\\n- **Optimiza rendimiento** evitando peticiones duplicadas\\n\\n## üîß Personalizaci√≥n\\n\\n### Agregar nuevas herramientas\\n\\n1. Definir en `src/mcp-tools.ts`\\n2. Implementar handler en `src/tool-handlers.ts`\\n3. Usar `ApiService` para peticiones HTTP\\n\\n### Configurar diferentes APIs\\n\\n- Modificar `API_BASE_URL` en variables de entorno\\n- Ajustar headers de autenticaci√≥n en `ApiService`\\n- Personalizar manejo de errores seg√∫n la API\\n\\n## üìÑ Licencia\\n\\nMIT License",
			"required": true,
			"description": "Documentaci√≥n del proyecto API"
		},
		"mcp.json": {
			"content": "{\\n\\t\\\"mcpServers\\\": {\\n\\t\\t\\\"{{KEBAB_CASE_NAME}}\\\": {\\n\\t\\t\\t\\\"command\\\": \\\"npx\\\",\\n\\t\\t\\t\\\"args\\\": [\\\"{{KEBAB_CASE_NAME}}\\\"],\\n\\t\\t\\t\\\"env\\\": {\\n\\t\\t\\t\\t\\\"MCP_TRANSPORT\\\": \\\"stdio\\\",\\n\\t\\t\\t\\t\\\"API_KEY\\\": \\\"your-api-key-here\\\"\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}",
			"required": true,
			"description": "Configuraci√≥n para Claude Desktop"
		}
	}
}
